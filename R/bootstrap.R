#' Bootstrapping - case resampling
#'
#' Generate replicates of the original data using random sampling with replacement.
#' Population parameters are then estimated from each replicate.
#' @param project Monolix project 
#' @param nboot [optional] number of bootstrap replicates (default=100)
#' @param dataFolder [optional] folder where already generated datasets are stored, e.g dataFolder="./dummy_project/boot/" (default: data set are generated by bootmlx)
#' @param settings [optional] a list of settings for the resampling and the results:
#' \itemize{
#' \item \code{N} the number of individuals in each bootstrap data set 
#' (default value is the  number of individuals in the original data set).
#' \item \code{newResampling} boolean to generate the data sets again if they already exist (default=FALSE).
#' \item \code{strata} vector of categorical covariates of the project. The original distribution of these covariates
#' is maintained in each resampled data set if strata is defined (default=NULL).
#' \item \code{plot} boolean to choose if the distribution of the bootstraped esimates is displayed
#' (default = TRUE)
#' \item \code{level} level of the bootstrap confidence intervals of the population parameters
#' (default = 0.90)
#' }
#' @return a data frame with the bootstrap estimates
#' @importFrom graphics boxplot lines par plot
#' @importFrom stats quantile
#' @export
bootmlx <- function(project, nboot = 100, dataFolder = NULL, settings = NULL){
  
  if (!grepl("\\.",project))
    project <- paste0(project,".mlxtran")
  if(!file.exists(project)){
    message(paste0("ERROR: project '", project, "' does not exists"))
    return(invisible(FALSE))}
  lp <- loadProject(project) 
  if (!lp) return(invisible(FALSE))

    # Check and initialize the settings
  if(is.null(settings$plot)){ plot.res <- TRUE }else{ plot.res <- settings$plot; settings$plot<- NULL}
  if(is.null(settings$level)){ level <- 0.90 }else{ level <- settings$level; settings$level<- NULL}
  settings$nboot <- nboot
  if(!is.null(settings)){
    if(!.checkBootstrapInput(inputName = "settings", inputValue = settings)){return(invisible(FALSE))}
  }
  if(is.null(settings$nboot)){ settings$nboot <- 100 }
  if(is.null(settings[['N']])){ settings[['N']] <- NA}
  if(is.null(settings$newResampling)){ settings$newResampling <- FALSE}
  if(is.null(settings$strata)){ settings$strata <- NA}
  
  
  if(!is.null(dataFolder)){
    dataFiles <- list.files(path = dataFolder, pattern = '*.txt|*.csv')
    if(length(dataFiles)>0){
      settings$nboot <- length(dataFiles)
      settings$newResampling <- FALSE
    }else{
      message("WARNING: Folder ",dataFolder,' does not exist or does not contain any data set')
      return(invisible(FALSE))
    }
  }
  
  # Prepare all the output folders
  param <- getPopulationParameterInformation()$name[which(getPopulationParameterInformation()$method!="FIXED")]
  exportDir <- getProjectSettings()$directory
  projectName <- substr(basename(project), 1, nchar(basename(project))-8)
  
  if(settings$newResampling){
    cleanbootstrap(project)
  }
  
  if(is.null(dataFolder)){
    generateBootstrap(project=project, settings=settings)
  }else{
    generateBootstrap(project=project, settings=settings, dataFolder=dataFolder)
  }
  
  paramResults <- array(dim = c(settings$nboot, length(param)+1)) #+1 for column with run index
  for(indexSample in 1:settings$nboot){
    projectBoot <-  paste0(exportDir,'/bootstrap/',projectName,'_bootstrap_',toString(indexSample),'.mlxtran')
    loadProject(projectBoot)
    cat(paste0('Project ',toString(indexSample),'/',toString(settings$nboot)))
    
    # Check if the run was done
    if(!file.exists(paste0(getProjectSettings()$directory,'/populationParameters.txt'))){
      cat(' => Running SAEM \n')
      runScenario()
    }else{
      cat(' => already computed \n')
    }
    paramResults[indexSample,] <-  c(indexSample, getEstimatedPopulationParameters());
  }
  colnames(paramResults) <- c("Run",names(getEstimatedPopulationParameters()))
  
  # Plot the results
  if (plot.res) {
    nbFig <- length(param)
    x_NbFig <- ceiling(max(sqrt(nbFig),1)); y_NbFig <- ceiling(nbFig/x_NbFig)
    par(mfrow = c(x_NbFig, y_NbFig), oma = c(0, 3, 1, 1), mar = c(3, 1, 0, 3), mgp = c(1, 1, 0), xpd = NA)
    for(indexFigure in 1:nbFig){
      res <- paramResults[,indexFigure+1]
      resQ <- quantile(res,c((1-level)/2,(1+level)/2))
      bxp <- boxplot(res, xlab = paste0(colnames(paramResults)[indexFigure+1],'\n',level*100,'% CI: [',toString(round(resQ[1],3)),', ',toString(round(resQ[2],3)),']'))
    }
  }
  #res.file <- paste0(exportDir,'/bootstrap/',projectName,'bootstrapResults.txt')
  res.file <- file.path(exportDir,"bootstrap","populationParameters.txt")
  write.table(x = paramResults, file = res.file,
              eol = "\n", sep = ",", col.names = TRUE, quote = FALSE, row.names = FALSE)
  return(paramResults)
}



generateBootstrap = function(project, dataFolder=NULL, settings=NULL){
  
  
  if(!file.exists(project)){
    message(paste0("ERROR: project '", project, "' does not exist"))
    return(invisible(FALSE))}
  
  loadProject(project)   
  
  # define the scenario in order to only have SAEM
  setScenario(tasks =  c(populationParameterEstimation = TRUE))
  
  # Prepare all the output folders
  exportDir <- getProjectSettings()$directory
  projectName <- substr(basename(project), 1, nchar(basename(project))-8)
  dir.create(file.path(exportDir, 'bootstrap/'), showWarnings = FALSE, recursive = TRUE)
  
  # Get the data set information
  referenceDataset <- getData()
  cov <- getCovariateInformation()
  datasetFile <- referenceDataset$dataFile
  
  if(is.null(dataFolder)){
    cat("Generating data sets...\n")
    dir.create(file.path(exportDir, 'bootstrap/data/'), showWarnings = FALSE)
    
    # Load the data set
    dataset <- read.table(file=datasetFile, header = TRUE, sep = "", dec = ".")
    if(length(dataset[1,])==1){dataset <- read.table(file=datasetFile, header = TRUE, sep = ",", dec = ".")}
    if(length(dataset[1,])==1){dataset <- read.table(file=datasetFile, header = TRUE, sep = ";", dec = ".")}
    if(length(dataset[1,])==1){dataset <- read.table(file=datasetFile, header = TRUE, sep = "\t", dec = ".")}
    
    indexID <- which(referenceDataset$headerTypes=="id")
    nameID <- unique(dataset[, indexID])
    nbIndiv <- length(nameID)
    if(is.na(settings[['N']])){settings[['N']] = nbIndiv}
    
    validID <- list()
    if(is.na(settings$strata)){
      nbCAT = 1
      indexPropCAT <- 1
      propCAT <- rep(settings[['N']], nbCAT)
      validID[[indexPropCAT]] <- nameID
    }else{
      indexCAT <- which(cov$name == settings$strata)
      catValues <- cov$covariate[,indexCAT+1]# +1 comes from the ID column
      nameCAT <- unique(catValues)
      nbCAT <- length(nameCAT)
      propCAT <- rep(settings[['N']], nbCAT)
      validID <- list()
      for(indexPropCAT in 1:nbCAT){
        indexIdCat <- which(catValues==nameCAT[indexPropCAT])
        propCAT[indexPropCAT] <- max(1,floor(settings[['N']]*length(indexIdCat)/nbIndiv))
        validID[[indexPropCAT]] <- as.character(cov$covariate[indexIdCat,1])
      }
    }
    cat("Generating projects with bootstrap data sets...\n")
    for(indexSample in 1:settings$nboot){
      datasetFileName <- paste0(exportDir,'/bootstrap/data/dataset_',toString(indexSample),'.csv')
      if(!file.exists(datasetFileName)){
        ##################################################################################################################
        # Generate the data set
        ##################################################################################################################
        # Sample the IDs
        sampleIDs <- NULL
        for(indexValidID in 1:length(validID)){
          sampleIDs <- c(sampleIDs,  sample(x = validID[[indexValidID]], size = propCAT[indexValidID], replace = TRUE) )
        }
        # get the datas
        data <- NULL
        for(indexSampleSize in 1:length(sampleIDs)){
          indexLine <- which(dataset[,indexID]==sampleIDs[indexSampleSize])
          dataToInsert <- dataset[indexLine,]
          dataToInsert[,indexID] <- indexSampleSize
          data <- rbind(data, dataToInsert)
        }
        
        write.table(x = data, file = datasetFileName,
                    eol = '\n', quote = FALSE, dec = '.',  row.names = FALSE, col.names = TRUE )
      }
      ##################################################################################################################
      # Generate the project file
      ##################################################################################################################
      # set the data file and the export directory
      bootData <- referenceDataset
      bootData$dataFile <- datasetFileName
      setData(bootData)
      saveProject(projectFile = paste0(exportDir,'/bootstrap/',projectName,'_bootstrap_',toString(indexSample),'.mlxtran'))
    }
  }else{
    cat("Reading data sets from the dataFolder...\n")
    dataFiles <- list.files(path = dataFolder, pattern = '*.txt|*.csv')
    cat("Generating projects with bootstrap data sets...\n")
    for(indexSample in 1:length(dataFiles)){
      bootData <- referenceDataset
      bootData$dataFile <- paste0(dataFolder,dataFiles[indexSample])
      setData(bootData)
      saveProject(projectFile = paste0(exportDir,'/bootstrap/',projectName,'_bootstrap_',toString(indexSample),'.mlxtran'))
    }
  }
  
}

##################################################################################################################
# Clean the bootstrap folder
##################################################################################################################
cleanbootstrap <- function(project){
  # Prepare all the output folders
  exportDir <- getProjectSettings()$directory
  listProjectsToDelete <-list.files(path = paste0(exportDir,'/bootstrap/'),pattern = '*.mlxtran')
  
  if(length(listProjectsToDelete)>0){
    for(indexProject in 1:length(listProjectsToDelete)){
      projectBoot <-  paste0(exportDir,'/bootstrap/',listProjectsToDelete[indexProject])
      loadProject(projectBoot)
      exportDirToClean <- getProjectSettings()$directory
      unlink(exportDirToClean, recursive = TRUE)
      unlink(projectBoot, recursive = FALSE)
    }
    unlink(file.path(exportDir, '/bootstrap/data/'), recursive = FALSE)
  }
}


###################################################################################
# Check the inputs
###################################################################################
.checkBootstrapInput = function(inputName, inputValue){
  isValid = TRUE
  inputName = tolower(inputName)
  if(inputName == tolower("settings")){
    if(is.list(inputValue) == FALSE){
      message("ERROR: Unexpected type encountered. settings must be a list")
      isValid = FALSE
    }else {
      for (i in 1:length(inputValue)){
        if(!.checkBootstrapSettings(settingName = names(inputValue)[i], settingValue = inputValue[[i]])){
          isValid = FALSE
        }
      }
    }
  }
  return(invisible(isValid))
}

.checkBootstrapSettings = function(settingName, settingValue){
  isValid = TRUE
  settingName = tolower(settingName)
  if(settingName == tolower("nboot")){
    if((is.double(settingValue) == FALSE)&&(is.integer(settingValue) == FALSE)){
      message("ERROR: Unexpected type encountered. nboot must be an integer.")
      isValid = FALSE
    }else{
      if(!(as.integer(settingValue) == settingValue)){
        message("ERROR: Unexpected type encountered. nboot must be an integer.")
        isValid = FALSE
      }else if(settingValue<1){
        message("ERROR: nboot must be a strictly positive integer.")
        isValid = FALSE
      }
    }
  }else if(settingName == tolower("N")){
    if((is.double(settingValue) == FALSE)&&(is.integer(settingValue) == FALSE)){
      message("ERROR: Unexpected type encountered. N must be an integer.")
      isValid = FALSE
    }else{
      if(!(as.integer(settingValue) == settingValue)){
        message("ERROR: Unexpected type encountered. N must be an integer.")
        isValid = FALSE
      }else if(settingValue<1){
        message("ERROR: N must be a strictly positive integer.")
        isValid = FALSE
      }
    }
  }else if(settingName == tolower("newResampling")){
    if((is.logical(settingValue) == FALSE)){
      message("ERROR: Unexpected type encountered. newResampling must be an boolean")
      isValid = FALSE
    }
  }else if(settingName == tolower("strata")){
    if(is.vector(settingValue) == FALSE){
      message("ERROR: Unexpected type encountered. strata must be a vector")
      isValid = FALSE
    }else{
      if(length(intersect(getCovariateInformation()$name, settingValue))==0){
        message(paste0("ERROR: ",settingValue," is not a valid covariate of the project."))
        isValid = FALSE
      }else{
        indexCAT <- which(getCovariateInformation()$name==settingValue)
        catType <- getCovariateInformation()$type[indexCAT[1]]
        if(!((catType=="categorical")||(catType=="categoricaltransformed"))){
          message(paste0("ERROR: ",settingValue," is not a categorical covariate."))
          isValid = FALSE
        }
      }
    }
  }else{
    message("ERROR: ",settingName,' is not a valid setting.')
    isValid = FALSE
  }
  return(isValid)
}